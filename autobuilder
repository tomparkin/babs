#!/bin/bash
#
# Autobuilder script
#
readonly CARGS="hf:"
readonly EVENT_ID_SCAN_TREE="@@DO_TREE_SCAN"
readonly EVENT_ID_BUILD_REPORT_READY="@@REPORT_READY"
readonly EVENT_ID_PROCESS_BUILD_QUEUE="@@PROCESS_BUILD_QUEUE"

# Absolute paths
JOBRUNNER_PATH="/opt/jobrunner/bin/jobrunner"
CONFIG_FILE_PATH="/etc/autobuilder.ini"

# These are relative to $WORKDIR, and are set after config parsing
IN_FLIGHT_LOG="$(basename $0)-in-flight.txt"
LAST_BUILT_LOG="$(basename $0)-lastbuilt.txt"
EVENT_QUEUE="$(basename $0)-eventqueue.txt"
BUILD_QUEUE="$(basename $0)-buildqueue.txt"
REPORT_QUEUE="$(basename $0)-reportqueue.txt"

# Read in from the configuration file
MACHINE_POOL=
REMOTE_USER=
WORKDIR=

# Arrays populated per config section
NUMBER_OF_BUILDS=0
declare -a BUILD_TITLE
declare -a CHECKOUT_METHOD
declare -a MODULES_FILE_ROOT
declare -a BRANCH
declare -a BUILD_SCRIPT

# Load library functions
. $(dirname $0)/liblog.sh
. $(dirname $0)/libini.sh
. $(dirname $0)/libpmrpc.sh
. $(dirname $0)/libqueue.sh
. $(dirname $0)/libevent.sh

show_usage() {
   cat << __EOF__
   Name:    $(basename $0)
   Desc:    TODO
   Usage:   $(basename $0) [options] <cmd>
            -h    print usage information
            -f    configuration file [default: $CONFIG_FILE_PATH]
            -r    <id@outcome@report ip:report path> report a build result
            -i    <build name@revision> inject a build
__EOF__
}

trim_string() { echo "$@" | sed 's=^ \+==g;s= \+$==g'; }

# $1 -- runner ip address
select_report_ip_address() {
   # If a machine has multiple interfaces we need to guess
   # which interface to use.  This is a kludge but it works
   # OK assuming Pace corporate v.s. Cora VLAN addresses.
   # Really we should look at route to figure it out.
   local ip=

   for ip in $(ifconfig | awk '/inet addr/ { split($2,a,/:/); print a[2]; }')
   do
      # FIXME: use route...
      if test "${ip%%.*}" = ${1%%.*}
      then
         echo $ip
         return 0
      fi
   done
}

parse_configuration() {
   local i=
   local n=0

   # First, extract the global configuration information
   REMOTE_USER=$(ini_get_value $CONFIG_FILE_PATH global remote_username)
   test "x$REMOTE_USER" = "x" && return 1
   dbg "Remote user = $REMOTE_USER"

   WORKDIR=$(ini_get_value $CONFIG_FILE_PATH global working_directory)
   test "x$WORKDIR" = "x" && return 1
   dbg "Working directory = $WORKDIR"

   # Now extract the machines from the machine pool
   for i in $(ini_get_values_in_section $CONFIG_FILE_PATH machine_pool)
   do
      MACHINE_POOL="$MACHINE_POOL $i"
   done
   MACHINE_POOL=$(trim_string $MACHINE_POOL)
   test "x$MACHINE_POOL" = "x" && return 1
   dbg "Machine pool = $MACHINE_POOL"

   # Parse the buildspec sections
   for i in $(ini_get_section_list $CONFIG_FILE_PATH)
   do
      # Ignore the global and machine pool sections...
      test "global" = "$i" && continue
      test "machine_pool" = "$i" && continue

      BUILD_TITLE[$n]=$i
      CHECKOUT_METHOD[$n]=$(ini_get_value $CONFIG_FILE_PATH $i checkout_method)
      MODULES_FILE_ROOT[$n]=$(ini_get_value $CONFIG_FILE_PATH $i modules_file_root)
      BRANCH[$n]=$(ini_get_value $CONFIG_FILE_PATH $i branch)
      BUILD_SCRIPT[$n]=$(ini_get_value $CONFIG_FILE_PATH $i build_script)

      # We must have at least this subset of possible values defined
      test "x${CHECKOUT_METHOD[$n]}" = "x" && return 1
      test "x${MODULES_FILE_ROOT[$n]}" = "x" && return 1
      test "x${BUILD_SCRIPT[$n]}" = "x" && return 1

      dbg "Adding build ${BUILD_TITLE[$n]}:"
      dbg "    checkout method   = ${CHECKOUT_METHOD[$n]}"
      dbg "    modules file root = ${MODULES_FILE_ROOT[$n]}"
      dbg "    branch            = ${BRANCH[$n]}"
      dbg "    build script      = ${BUILD_SCRIPT[$n]}"

      NUMBER_OF_BUILDS=$((NUMBER_OF_BUILDS+1))
      n=$((n+1))
   done
}

# $1 -- build name
get_last_build_revision() {
   if test -f "$LAST_BUILT_LOG"
   then
      grep "$1" $LAST_BUILT_LOG | sed 's/^.*=//g;s/ //g'
   else
      false
   fi
}

# $1 -- build name
# $2 -- build revision
set_last_build_revision() {
   if test -f "$LAST_BUILT_LOG"
   then
      grep -v "$1" $LAST_BUILT_LOG > ${LAST_BUILT_LOG}.new
   fi
   echo "$1 = $2" >> ${LAST_BUILT_LOG}.new && mv ${LAST_BUILT_LOG}.new ${LAST_BUILT_LOG}
}

# $1 -- build name
# $2 -- build revision
# $3 -- runner
build_info_to_inflight() { echo "$(date +%H:%M:%S-%d/%m/%Y) $1 $2 runner $3"; }

# $1 -- inflight log line
inflight_to_build_name() { echo "$1" | cut -d" " -f2; }

# $1 -- inflight log line
inflight_to_build_rev() { echo "$1" | cut -d" " -f3; }

# $1 -- inflight log line
inflight_to_build_runner() { echo "$1" | cut -d" " -f5; }

# $1 -- build name
# $2 -- build revision
# $3 -- runner
add_build_to_inflight_list() { build_info_to_inflight $1 $2 $3 >> $IN_FLIGHT_LOG; }

# $1 -- build name
# $2 -- build revision
remove_build_from_inflight_list() {
   if test -f "$IN_FLIGHT_LOG"
   then
      grep -v "$1.*$2" "$IN_FLIGHT_LOG" > ${IN_FLIGHT_LOG}.new
      mv ${IN_FLIGHT_LOG}.new ${IN_FLIGHT_LOG}
   fi
}

# $1 -- build revision
lookup_inflight_build_by_revision() {
   local l=
   test "x$1" = "x" && return 1
   if test -f "$IN_FLIGHT_LOG"
   then
      awk -v rev=$1 '$3 == rev { print }' "$IN_FLIGHT_LOG"
   fi
}

# $1 -- modules file path
# $2 -- branch name (optional)
cvs_get_build_rev() {
   local branch="HEAD"
   local cmd=""
   test "x$1" = "x" && return 1
   test "x$2" && branch="$2"
   cmd="cvs co -p -r $branch Products/${1}/modules 2>&1 | grep Revision | cut -d' ' -f3"
   dbg "$cmd"
   eval $cmd
}

# $1 -- modules file path
# $2 -- branch name (optional)
snssvn_get_build_rev() {
   local branch="trunk"
   local cmd=""
   test "x$1" = "x" && return 1
   test "x$2" != "x" && test "$2" != "trunk" && branch="branches/$2"
   cmd="svn cat -r HEAD http://svn.pace.internal/svn/s-and-s/Products/${1}/${branch}/modules | grep Revision | cut -d' ' -f3"
   dbg "$cmd"
   eval $cmd
}

# $1 -- build id number
get_current_revision() {
   local current_rev=
   test "x$1" = "x" && return 1
   case ${CHECKOUT_METHOD[$1]} in
      cvs) current_rev="$(cvs_get_build_rev ${MODULES_FILE_ROOT[$1]} ${BRANCH[$1]})" ;;
      snssvn) current_rev="$(snssvn_get_build_rev ${MODULES_FILE_ROOT[$1]} ${BRANCH[$1]})" ;;
      *) err "Unsupported checkout method ${CHECKOUT_METHOD[$1]}" ;;
   esac
   current_rev=$(trim_string "$current_rev")
   test "x$current_rev" = "x" && return 1
   echo $current_rev
}

# $1 -- ip address
get_machine_queue_length() {
   test -n "$1" || return 1
   pmrpc_run_command $REMOTE_USER $1 "$JOBRUNNER_PATH queuelength"
}

# $1 -- ip address
show_machine_queue() {
   test -n "$1" || return 1
   pmrpc_run_command $REMOTE_USER $1 "$JOBRUNNER_PATH show"
}

# $1 -- revision
# $2 -- ip address
# $3 -- build script
# $4 -- report script
push_build_to_runner_machine() {
   local current_rev=
   local runner_ip=
   local build_script=
   local report_script=
   local my_ip=
   local jobcmd=

   test "x$1" = "x" && return 1 || current_rev="$1"
   test "x$2" = "x" && return 1 || runner_ip="$2"
   test "x$3" = "x" && return 1 || build_script="$3"
   test "x$4" = "x" && return 1 || report_script="$4"

   if ! my_ip=$(select_report_ip_address "$runner_ip")
   then
      err "Failed to determine which local interface to use for reporting"
      return 1
   fi

   jobcmd="$JOBRUNNER_PATH add $current_rev $my_ip:$build_script $my_ip:$report_script"
   dbg "Asking $REMOTE_USER@$runner_ip to execute job command $jobcmd"
   pmrpc_run_command $REMOTE_USER $runner_ip "$jobcmd"
}

# Select a runner to use
pick_runner_machine() {
   local l=
   local m=
   local minlen=
   local idlemachine=

   # Pick a runner based on who has the shortest queue
   for m in $MACHINE_POOL
   do
      if l=$(get_machine_queue_length "$m")
      then
         dbg "Machine $m has $l jobs queued"
         if test -z "$minlen" || test $l -lt $minlen
         then
            minlen=$l
            idlemachine=$m
         fi
      else
         err "Failed to complete pmrpc request to $m (machine said: $l)"
      fi
   done

   test -n "$idlemachine" || return 1
   echo $idlemachine
}

# Scan VCS trees for updates, queue builds for processing
do_tree_scan() {
   local current_revision=
   local previous_revision=
   local current_rev=
   local runner=

   # Check the tree for each of the builds
   for ((i=0;i<$NUMBER_OF_BUILDS;i++))
   do
      # What is revision is the tree at?
      previous_revision="$(get_last_build_revision ${BUILD_TITLE[$i]})"
      if ! current_revision=$(get_current_revision $i)
      then
         err "Failed to determine tree revision for ${BUILD_TITLE[$i]}"
         continue
      fi

      # Does the tree need building?
      if test "$previous_revision" != "$current_revision"
      then
         local msg=
         test "x$previous_revision" = "x" && msg="never built before" || msg="last build was $previous_revision"
         logts "${BUILD_TITLE[$i]} needs a build ($msg, current rev is $current_revision)"
      else
         dbg "${BUILD_TITLE[$i]} is up to date at revision $current_revision"
         continue
      fi

      # Add the build to the queue for processing
      if enqueue_build "$i" "$current_revision"
      then
         dbg "Revision $current_revision of ${BUILD_TITLE[$i]} queued for pushing out to the pool"
      else
         err "Failed to enqueue rev. $current_revision of ${BUILD_TITLE[$i]}"
      fi
   done
}

# $1 -- build id
# $2 -- build revision
buildspec_to_buildqueue() { echo "$1@$2"; }

# $1 -- buildqueue line
buildqueue_to_build_id() { echo "$1" | cut -d"@" -f1; }

# $1 -- buildqueue line
buildqueue_to_build_rev() { echo "$1" | cut -d"@" -f2; }

# Add a build the the build queue for passing out to the
# machine pool for processing.  The actual push process is
# carried out via. process_build_queue().
# $1 -- build id
# $2 -- build revision
enqueue_build() {
   test "x$1" = "x" && return 1
   test "x$2" = "x" && return 2

   queue_lock "$BUILD_QUEUE"
   queue_add "$BUILD_QUEUE" $(buildspec_to_buildqueue "$1" "$2")
   queue_unlock "$BUILD_QUEUE"
}

# $1 -- build id
# $2 -- revision
# $3 -- runner
generate_report_script() {
   test "x${1}" = "x" && return 1
   test "x${2}" = "x" && return 1
   test "x${3}" = "x" && return 1
   local script=${WORKDIR}/$(basename $0)-${BUILD_TITLE[$1]}-${2}-${3}-$(date +%s)_REPORT.sh
   cat > $script << __EOF__
#!/bin/bash

# Input arguments: \$1 -- SUCCESS or FAIL; \$2 -- report ip/path string
# This script should be executed on the build master by the build runner machine

# Return result for ${BUILD_TITLE[$1]} rev $2 executed on runner $3
$0 -f ${CONFIG_FILE_PATH} report ${BUILD_TITLE[$1]} ${2} ${3} \$1 \$2
__EOF__
   test -f "$script" && chmod +x "$script" && echo "$script"
}

# $1 -- build id
# $2 -- revision
# $3 -- runner
generate_build_script() {
   test "x${1}" = "x" && return 1
   test "x${2}" = "x" && return 1
   test "x${3}" = "x" && return 1
   local script=${WORKDIR}/$(basename $0)-${BUILD_TITLE[$1]}-${2}-${3}-$(date +%s)_BUILD.sh
   cat > $script << __EOF__
#!/bin/bash

# This script should be executed on the build runner.  It is autogenerated
# from ${BUILD_SCRIPT[$1]} with some variables added by $(basename $0).

# These variables are provided by $(basename $0)
AUTOBUILDER_BRANCH_NAME=${BRANCH[$1]}
AUTOBUILDER_REVISION=$2
AUTOBUILDER_BUILD_TITLE=${BUILD_TITLE[$1]}
AUTOBUILDER_WORKROOT=/export/home/autobuild

# The rest of this script is pasted from ${BUILD_SCRIPT[$1]}
$(grep -v "^#\!" ${BUILD_SCRIPT[$1]})
__EOF__
   test -f "$script" && chmod +x "$script" && echo "$script"
}

# Pass each entry in the build queue out to the machine pool for execution
process_build_queue() {
   local runner=
   local q=
   local id=
   local rev=
   local build_script=
   local report_script=
   local ret=0

   while true
   do
      # Pop a buildspec off the queue
      queue_lock "$BUILD_QUEUE"
      q=$(queue_pop_eldest "$BUILD_QUEUE")
      queue_unlock "$BUILD_QUEUE"
      id="$(buildqueue_to_build_id "$q")"
      rev="$(buildqueue_to_build_rev "$q")"

      # If we didn't get a spec we're at the end of the queue...
      test -n "$rev" && test -n "$id" || break

      # Select which machine in the pool should execute the build
      if ! runner=$(pick_runner_machine)
      then
         err "Failed to select machine to run ${BUILD_TITLE[$id]} revision $rev"
         ret=$((ret+1))
         continue
      fi

      # Generate a build script for the runner
      if ! build_script=$(generate_build_script $id $rev $runner)
      then
         err "Failed to generate build script for ${BUILD_TITLE[$id]} revision $rev"
         ret=$((ret+1))
         continue
      fi

      # Generate a report script for the runner
      if ! report_script=$(generate_report_script $id $rev $runner)
      then
         err "Failed to generate reporting script for ${BUILD_TITLE[$id]} revision $rev"
         ret=$((ret+1))
         continue
      fi

      # Push the build out
      if push_build_to_runner_machine "$rev" $runner "$build_script" "$report_script"
      then
         logts "${BUILD_TITLE[$id]} revision $rev to be processed by runner $runner"
         set_last_build_revision "${BUILD_TITLE[$id]}" "$rev"
         add_build_to_inflight_list "${BUILD_TITLE[$id]}" "$rev" "$runner"
      else
         err "Failed to push ${BUILD_TITLE[$id]} revision $rev build to runner $runner"
         ret=$((ret+1))
         continue
      fi
   done
   dbg "Finished processing build queue"
   return $ret
}

process_report_queue() {
   local report=
   local ret=0
   local build_title=
   local build_revision=
   local build_runner=
   local build_result=
   local build_report=
   local inflight=

   while true
   do
      queue_lock "$REPORT_QUEUE"
      report="$(queue_pop_eldest "$REPORT_QUEUE")"
      queue_unlock "$REPORT_QUEUE"

      # Empty result means the queue is empty
      test "x$report" = "x" && break

      build_title=$(reportstring_to_build_title "$report")
      build_revision=$(reportstring_to_revision "$report")
      build_runner=$(reportstring_to_runner_ip "$report")
      build_result=$(reportstring_to_result "$report")
      build_report=$(reportstring_to_report_path "$report")

      logts "Runner $build_runner reported $build_result for $build_title revision $build_revision"

      # Find this build in our "in flight" build list
      if ! inflight=$(lookup_inflight_build_by_revision "$build_revision")
      then
         err "Couldn't locate build on inflight list -- reports will be dropped :-("
         ret=$((ret+1))
         continue
      fi

      # Remove from the inflight list
      if ! remove_build_from_inflight_list "$build_title" "$build_revision"
      then
         err "Failed to remove build from inflight list"
         ret=$((ret+1))
         continue
      fi

      logts "TODO: email results"
   done
   dbg "Finished processing report queue"
   return $ret
}

# $1 -- build title
# $2 -- revision
# $3 -- runner ip
# $4 -- result
# $5 -- report path
report_to_queuestring() {
   test "x${1}" = "x" && return 1
   test "x${2}" = "x" && return 1
   test "x${3}" = "x" && return 1
   test "x${4}" = "x" && return 1
   test "x${5}" = "x" && return 1

   if test "${4}" != "SUCCESS" && test "${4}" != "FAILURE"
   then
      return 1
   fi

   #__check_path "$5" || return 1
   __is_dotted_quad "$3" || return 1

   echo "${1}@${2}@${3}@${4}@${5}"
}

# $1 -- report string
reportstring_to_build_title() {
   test "x${1}" = "x" && return 1
   echo "${1}" | cut -d"@" -f1
}

# $1 -- report string
reportstring_to_revision() {
   test "x${1}" = "x" && return 1
   echo "${1}" | cut -d"@" -f2
}

# $1 -- report string
reportstring_to_runner_ip() {
   local s=
   test "x${1}" = "x" && return 1
   s=$(echo "${1}" | cut -d"@" -f3)
   __is_dotted_quad "$s" && echo "$s"
}

# $1 -- report string
reportstring_to_result() {
   local s=
   test "x${1}" = "x" && return 1
   s=$(echo "${1}" | cut -d"@" -f4)
   if test "${s}" = "SUCCESS" || test "${s}" = "FAILURE"
   then
      echo $s
   fi
}

# $1 -- report string
reportstring_to_report_path() {
   local s=
   test "x${1}" = "x" && return 1
   s=$(echo "${1}" | cut -d"@" -f5)a
   #__check_path "$s" && echo "$s"
}

# Add a build result to the reporting queue
report_result() {
   local s=

   if ! s=$(report_to_queuestring "$1" "$2" "$3" "$4" "$5")
   then
      err "Failed to convert inputs to a report string"
      return 1
   fi

   # Add the report to the report queue
   queue_lock "$REPORT_QUEUE"
   if ! queue_add "$REPORT_QUEUE" "$s"
   then
      err "Failed to add report into report queue"
      queue_unlock "$REPORT_QUEUE"
      return 1
   fi
   queue_unlock "$REPORT_QUEUE"

   # Generate a report ready event for the master
   event_write "$EVENT_QUEUE" "$EVENT_ID_BUILD_REPORT_READY"
}

# Add a build request into the build queue
request_build() {
   err "Not implemented yet"
   false
}

# Trigger a revision scan
request_revision_scan() {
   dbg "Request tree scan ($EVENT_QUEUE)"
   event_write "$EVENT_QUEUE" "$EVENT_ID_SCAN_TREE"
   event_write "$EVENT_QUEUE" "$EVENT_ID_PROCESS_BUILD_QUEUE"
}

#
# Entry point
#
while getopts $CARGS opt
do
   case $opt in
      h) show_usage; exit 0 ;;
      f) CONFIG_FILE_PATH=$OPTARG ;;
      *) die "Unrecognised option" ;;
   esac
done
shift $((OPTIND-1))

test -f "$CONFIG_FILE_PATH" || die "Configuration file $CONFIG_FILE_PATH not found"

logts "Parse configuration from $CONFIG_FILE_PATH"
parse_configuration || die "Failed to parse configuration $CONFIG_FILE_PATH"

# Set up paths for workdir files
LAST_BUILT_LOG="${WORKDIR}/${LAST_BUILT_LOG}"
IN_FLIGHT_LOG="${WORKDIR}/${IN_FLIGHT_LOG}"
EVENT_QUEUE="${WORKDIR}/${EVENT_QUEUE}"
BUILD_QUEUE="${WORKDIR}/${BUILD_QUEUE}"
REPORT_QUEUE="${WORKDIR}/${REPORT_QUEUE}"

case $1 in
   scan) request_revision_scan ;;
   requestbuild) shift; request_build "$@" ;;
   report) shift; report_result $@ ;;
   run)
      # Ensure we clean up after ourselves...
      trap "rm -f $BUILD_QUEUE $EVENT_QUEUE $REPORT_QUEUE" EXIT

      # Event loop
      while true
      do
         # Wait for an input event
         if event=$(event_blocking_read $EVENT_QUEUE)
         then
            dbg "New event: $event"
            case $event in
               $EVENT_ID_SCAN_TREE)
                  do_tree_scan
               ;;
               $EVENT_ID_BUILD_REPORT_READY)
                  if ! process_report_queue
                  then
                     err "Errors processing the report queue -- some reports may be dropped :-("
                  fi
               ;;
               $EVENT_ID_PROCESS_BUILD_QUEUE)
                  if ! process_build_queue
                  then
                     err "Errors processing the build queue -- some builds may be dropped :-("
                  fi
               ;;
               *) err "Unrecognised input event \"$event\"" ;;
            esac
         fi
      done
   ;;
   *) die "Unrecognised command $1" ;;
esac
