#!/bin/bash
#
# Autobuilder script
#
readonly CARGS="hf:"

JOBRUNNER_PATH="/opt/jobrunner/bin/jobrunner"
CONFIG_FILE_PATH="/etc/autobuilder.ini"
LAST_BUILT_LOG="/tmp/$(basename $0)-lastbuilt.txt"

# Read in from the configuration file
INTERVAL=
MACHINE_POOL=
REMOTE_USER=

# Arrays populated per config section
NUMBER_OF_BUILDS=0
declare -a BUILD_TITLE
declare -a CHECKOUT_METHOD
declare -a MODULES_FILE_ROOT
declare -a BRANCH
declare -a BUILD_SCRIPT

# Load library functions
. $(dirname $0)/liblog.sh
. $(dirname $0)/libini.sh
. $(dirname $0)/libpmrpc.sh

show_usage() {
   cat << __EOF__
   Name:    $(basename $0)
   Desc:    TODO
   Usage:   $(basename $0) [options] <cmd>
            -h    print usage information
            -f    configuration file [default: $CONFIG_FILE_PATH]
__EOF__
}

logts() { log "[$(date)] $@"; }
trim_string() { echo "$@" | sed 's=^ \+==g;s= \+$==g'; }

parse_configuration() {
   local i=
   local n=0

   # First, extract the global configuration information
   INTERVAL=$(ini_get_value $CONFIG_FILE_PATH global interval)
   test "x$INTERVAL" = "x" && return 1
   dbg "Interval = $INTERVAL"

   REMOTE_USER=$(ini_get_value $CONFIG_FILE_PATH global remote_username)
   test "x$REMOTE_USER" = "x" && return 1
   dbg "Remote user = $REMOTE_USER"

   # Now extract the machines from the machine pool
   for i in $(ini_get_values_in_section $CONFIG_FILE_PATH machine_pool)
   do
      MACHINE_POOL="$MACHINE_POOL $i"
   done
   MACHINE_POOL=$(trim_string $MACHINE_POOL)
   test "x$MACHINE_POOL" = "x" && return 1
   dbg "Machine pool = $MACHINE_POOL"

   # Parse the buildspec sections
   for i in $(ini_get_section_list $CONFIG_FILE_PATH)
   do
      # Ignore the global and machine pool sections...
      test "global" = "$i" && continue
      test "machine_pool" = "$i" && continue

      BUILD_TITLE[$n]=$i
      CHECKOUT_METHOD[$n]=$(ini_get_value $CONFIG_FILE_PATH $i checkout_method)
      MODULES_FILE_ROOT[$n]=$(ini_get_value $CONFIG_FILE_PATH $i modules_file_root)
      BRANCH[$n]=$(ini_get_value $CONFIG_FILE_PATH $i branch)
      BUILD_SCRIPT[$n]=$(ini_get_value $CONFIG_FILE_PATH $i build_script)

      # We must have at least this subset of possible values defined
      test "x${CHECKOUT_METHOD[$n]}" = "x" && return 1
      test "x${MODULES_FILE_ROOT[$n]}" = "x" && return 1
      test "x${BUILD_SCRIPT[$n]}" = "x" && return 1

      dbg "Adding build ${BUILD_TITLE[$n]}:"
      dbg "    checkout method   = ${CHECKOUT_METHOD[$n]}"
      dbg "    modules file root = ${MODULES_FILE_ROOT[$n]}"
      dbg "    branch            = ${BRANCH[$n]}"
      dbg "    build script      = ${BUILD_SCRIPT[$n]}"

      NUMBER_OF_BUILDS=$((NUMBER_OF_BUILDS+1))
      n=$((n+1))
   done
}

# $1 -- build name
get_last_build_revision() {
   if test -f "$LAST_BUILT_LOG"
   then
      grep "$1" $LAST_BUILT_LOG | sed 's/^.*=//g;s/ //g'
   else
      false
   fi
}

# $1 -- build name
# $2 -- build revision
set_last_build_revision() {
   if test -f "$LAST_BUILT_LOG"
   then
      grep -v "$1" $LAST_BUILT_LOG > ${LAST_BUILT_LOG}.new
   fi
   echo "$1 = $2" >> ${LAST_BUILT_LOG}.new && mv ${LAST_BUILT_LOG}.new ${LAST_BUILT_LOG}
}

# $1 -- modules file path
# $2 -- branch name (optional)
cvs_get_build_rev() {
   local branch="HEAD"
   local cmd=""
   test "x$1" = "x" && return 1
   test "x$2" && branch="$2"
   cmd="cvs co -p -r $branch Products/${1}/modules 2>&1 | grep Revision | cut -d' ' -f3"
   dbg "$cmd"
   eval $cmd
}

# $1 -- modules file path
# $2 -- branch name (optional)
snssvn_get_build_rev() {
   local branch="trunk"
   local cmd=""
   test "x$1" = "x" && return 1
   test "x$2" != "x" && test "$2" != "trunk" && branch="branches/$2"
   cmd="svn cat -r HEAD http://svn.pace.internal/svn/s-and-s/Products/${1}/${branch}/modules | grep Revision | cut -d' ' -f3"
   dbg "$cmd"
   eval $cmd
}

# $1 -- build id number
get_current_revision() {
   local current_rev=
   test "x$1" = "x" && return 1
   case ${CHECKOUT_METHOD[$1]} in
      cvs) current_rev="$(cvs_get_build_rev ${MODULES_FILE_ROOT[$1]} ${BRANCH[$1]})" ;;
      snssvn) current_rev="$(snssvn_get_build_rev ${MODULES_FILE_ROOT[$1]} ${BRANCH[$1]})" ;;
      *) err "Unsupported checkout method ${CHECKOUT_METHOD[$1]}" ;;
   esac
   current_rev=$(trim_string "$current_rev")
   test "x$current_rev" = "x" && return 1
   echo $current_rev
}

# $1 -- ip address
get_machine_queue_length() {
   test -n "$1" || return 1
   pmrpc_run_command $REMOTE_USER $1 "$JOBRUNNER_PATH queuelength"
}

# $1 -- ip address
show_machine_queue() {
   test -n "$1" || return 1
   pmrpc_run_command $REMOTE_USER $1 "$JOBRUNNER_PATH show"
}

# $1 -- revision
# $2 -- ip address
# $3 -- build id number
push_build_to_runner_machine() {
   local current_rev=
   local ip=
   local build_id=
   local jobcmd=

   test "x$1" = "x" && return 1 || current_rev="$1"
   test "x$2" = "x" && return 1 || ip="$2"
   test "x$3" = "x" && return 1 || build_id="$3"

   # HACK!
   local myip=10.0.0.186
   jobcmd="$JOBRUNNER_PATH add $current_rev $myip:${BUILD_SCRIPT[$build_id]} $myip:/foo/bar/baz"
   dbg "Asking $REMOTE_USER@$ip to execute job command $jobcmd"
   pmrpc_run_command $REMOTE_USER $ip "$jobcmd"
}

# Select a runner to use
pick_runner_machine() {
   local l=
   local m=
   local minlen=
   local idlemachine=

   # Pick a runner based on who has the shortest queue
   for m in $MACHINE_POOL
   do
      if l=$(get_machine_queue_length "$m")
      then
         dbg "Machine $m has $l jobs queued"
         if test -z "$minlen" || test $l -lt $minlen
         then
            minlen=$l
            idlemachine=$m
         fi
      else
         err "Failed to complete pmrpc request to $m (machine said: $l)"
      fi
   done

   test -n "$idlemachine" || return 1
   echo $idlemachine
}

#
# Entry point
#
while getopts $CARGS opt
do
   case $opt in
      h) show_usage; exit 0 ;;
      f) CONFIG_FILE_PATH=$OPTARG ;;
      *) die "Unrecognised option" ;;
   esac
done

test -f "$CONFIG_FILE_PATH" || die "Configuration file $CONFIG_FILE_PATH not found"

logts "Parse configuration from $CONFIG_FILE_PATH"
parse_configuration || die "Failed to parse configuration $CONFIG_FILE_PATH"

while true
do
   # Check the tree for each of the builds
   for ((i=0;i<$NUMBER_OF_BUILDS;i++))
   do
      # What is revision is the tree at?
      previous_revision="$(get_last_build_revision ${BUILD_TITLE[$i]})"
      if ! current_revision=$(get_current_revision $i)
      then
         err "Failed to determine tree revision for ${BUILD_TITLE[$i]}"
         continue
      fi

      # Does the tree need building?
      if test "$previous_revision" != "$current_revision"
      then
         test "x$previous_revision" = "x" && msg="never built before" || msg="last build was $previous_revision"
         logts "${BUILD_TITLE[$i]} needs a build ($msg, current rev is $current_revision)"
      else
         dbg "${BUILD_TITLE[$i]} is up to date at revision $current_revision"
         continue
      fi

      # Select which machine in the pool should execute the build
      if runner=$(pick_runner_machine)
      then
         logts "Selected $runner to execute build"
         show_machine_queue $runner
      else
         err "Failed to select a runner machine from pool: $MACHINE_POOL"
         continue
      fi

      # Push the build out
      if push_build_to_runner_machine $current_revision $runner $i
      then
         logts "Scheduled build $current_revision on $runner"
         set_last_build_revision "${BUILD_TITLE[$i]}" "$current_revision"
      else
         err "Failed to add ${BUILD_TITLE[$i]} build to runner $runner"
         continue
      fi
   done

   # Sleep till the next time
   dbg "Sleeping for $INTERVAL seconds"
   sleep $INTERVAL
done
