#!/bin/bash
#
# testmaster
#
# Manages automated testing of Cora boxen
#
readonly CARGS="h"
readonly LOCKFILE=/tmp/$(basename $0)-lock
readonly QUEUEFILE=/tmp/$(basename $0)-candidate-queue

# TODO: admin mode with an admin lock to block out new reqs
#       while we're doing stuff interactively?

# TODO: test start

# TODO: test end

log() { echo "$@"; }
dbg() { test -n "$DEBUG" && log "$@" 1>&2; }
err() { log "ERROR: $@" 1>&2; false; }
die() { err "$@"; exit 1; }

#
# Queue locking functions -- don't leave it locked on exit!
#
acquire_lock()
{
   while true
   do
      if ( set -o noclobber; echo "$$" > $LOCKFILE ) 2>/dev/null
      then
         break
      else
         dbg "Wait for lock"
         sleep 1
      fi
   done
}

release_lock() { rm -f $LOCKFILE; }

#
# Queue manipulation functions.  If you're changing the queue
# then you should hold the queue lock while you're doing this.
#

# $1 -- ip
# $2 -- path
queue_add() { echo "${1}:${2}" >> ${QUEUEFILE}; }

queue_length() {
   if test -f ${QUEUEFILE}
   then
      wc -l ${QUEUEFILE} | cut -d " " -f1
   else
      echo 0
   fi
}

queue_pop_eldest() {
   if test $(queue_length) -gt 0
   then
      head -1 ${QUEUEFILE}
      tail -$(($(queue_length)-1)) ${QUEUEFILE} > ${QUEUEFILE}.new && mv ${QUEUEFILE}.new ${QUEUEFILE}
   else
      echo
   fi
}

queue_pop_youngest() {
   if test $(queue_length) -gt 0
   then
      tail -1 ${QUEUEFILE}
      head -$(( $(queue_length) - 1 )) ${QUEUEFILE} > ${QUEUEFILE}.new && mv ${QUEUEFILE}.new ${QUEUEFILE}
   else
      echo
   fi
}

queue_flush() { rm -f ${QUEUEFILE}; }

queue_dump() {
   if test $(queue_length) -gt 0
   then
      awk '{print NR ". " $0}' ${QUEUEFILE}
   else
      log "Queue is empty"
   fi
}

#
# STB communications
#

# $1 -- ip address
# $2 -- username
# $3 -- command to run
# $4 -- timeout (optional)
stb_expect() {

}

#
# Command handler functions
#

# $1 -- ip address of job host
# $2 -- path to job script
handle_add()
{
   local ip_add="$1"
   local path="$2"

   # Sanity check
   if ! echo "$ip_add" | grep -q "[[:digit:]]\+\.[[:digit:]]\+\.[[:digit:]]\+\.[[:digit:]]\+"
   then
      err "IP address is not a dotted quad"
      return 1
   fi

   if test "x${path}" = "x"
   then
      err "No path specified"
      return 1
   fi

   # Add the ip/path combo to the queue
   acquire_lock
   queue_add "${ip_add}" "${path}"
   release_lock
}

# $1 -- candidate specification
# $2 -- queue flush control
handle_run()
{
   local spec="$1"
   local flush="$2"
   local candidate_config=

   # Sanity check
   if ! test "$spec" = "eldest" && ! test "$spec" = "youngest"
   then
      err "Candidate specification is invalid"
      return 1
   fi

   if ! test "$flush" = "flush" && ! test "$flush" = "noflush"
   then
      err "Queue flush argument is invalid"
      return 2
   fi

   if ! test $(queue_length) -gt 0
   then
      err "Input queue is empty"
      return 3
   fi

   # Mess with the queue -- hold the lock for this
   acquire_lock
   test "$spec" = "eldest" && candidate_config="$(queue_pop_eldest)" || candidate_config="$(queue_pop_youngest)"
   test "$flush" = "flush" && queue_flush
   release_lock

   # Now go ahead and run the build
   log "Run build $candidate_config"

   return 0
}

# $1 -- parse control
# $2 -- email control
handle_stop()
{
   local parse="$1"
   local email="$2"

   # Sanity check
   if ! test "$parse" = "parse" && ! test "$parse" = "noparse"
   then
      err "Parse argument is invalid"
      return 1
   fi

   if ! test "$email" = "email" && ! test "$email" = "noemail"
   then
      err "Email argument is invalid"
      return 2
   fi

   log "Stop the build: $parse, $email"
   return 0
}

# no args
handle_show()
{
   acquire_lock
   queue_dump
   release_lock
}

# $@ -- command and args
parse_cmd()
{
   local cmd=$1
   shift
   case $cmd in
      add) handle_add $@ ;;
      run) handle_run $@ ;;
      stop) handle_stop $@ ;;
      show) handle_show $@ ;;
      clearlock) rm -f ${LOCKFILE} ;;
      *) err "Unrecognised command $cmd" ;;
   esac
}

#
# Usage information
#
show_usage()
{
   cat << __EOF__
   Name:    $(basename $0)
   Desc:    TODO
   Usage:   $(basename $0) [options] <command> <arguments>
            -h       print this help information

   Commands:

            add <ip address> <autobuilder path>

            Add a build candidate to the input test queue.
            The IP address and autobuilder path should describe
            where the autobuilder outputs can be located for the
            candidate build.

            run <candidate spec> <flush queue>

            Run a build candidate on the test rig.
            The candidate specification can be either "youngest"
            for the most recently added candidate in the queue, or
            "eldest" for the least recently added candidate in the
            queue.
            The "flush queue" argument can be either "flush" to
            flush out all the contents of the input queue, or "noflush"
            to leave the queue intact, removing only slot containing
            the candidate to be run.

            stop <parse logs> <email team>

            Terminate the current test run in progress.
            The parse logs argument can be either "parse" or "noparse".
            If it is "parse", the logs from the test run will be parsed
            using parselogs and parsemrecord.  If it is "noparse" no
            parsing will be carried out.
            The email team argument can be either "email" or "noemail".
            If it is "email" then the team will be emailed a results
            summary.  If it is "noemail" no email will be generated.

            show

            Show the contents of the input queue.
__EOF__
}

#
# Entry point
#
while getopts $CARGS opt
do
   case $opt in
      h) log "Usage: $(basename $0) [options] <cmd> <args>" ;;
      *) die "Unrecognised option" ;;
   esac
done
shift $((OPTIND-1))

parse_cmd $@
